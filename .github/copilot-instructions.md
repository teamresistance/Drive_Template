# GitHub Copilot Instructions for Team Resistance #86

## Project Structure & Context

### Key Technologies

- **Language**: Java 17
- **Framework**: WPILib
- **Logging**: AdvantageKit
- **Motor Control**: Phoenix 6 (CTRE)
- **Pathfinding**: PathPlanner and Choreo
- **Vision**: PhotonVision + Studica NavX
- **Build Tool**: Gradle with Spotless formatting
- **Testing**: JUnit
- **Code Quality**: SonarQube integration

### Package Structure

- `frc.robot` - Main robot code (Robot.java, RobotContainer.java, Constants.java, etc.)
- `frc.robot.subsystems.drive` - Swerve drive subsystem with IO abstraction
- `frc.robot.subsystems.vision` - Vision processing subsystem
- `frc.robot.commands` - Robot commands (DriveCommands.java)
- `frc.robot.util` - Utility classes (GeomUtil, LoggedTunableNumber, PhoenixUtil, etc.)
- `frc.robot.generated` - Auto-generated files (TunerConstants.java from Phoenix Tuner X)

## Coding Standards & Best Practices

### Code Style

- Use WPILib Java code conventions enforced by Spotless
- Follow AdvantageKit patterns for IO abstraction
- Use descriptive variable and method names
- Include comprehensive JavaDoc comments for public methods
- Use proper exception handling for hardware failures
- Code formatting is automatically applied via `./gradlew spotlessApply`

### FRC-Specific Guidelines

- Use the command-based robot framework
- Implement proper subsystem requirements in commands
- Use AdvantageKit's IO layer pattern for hardware abstraction
- Log all important robot data using Logger.recordOutput()
- Handle robot modes (teleop, autonomous, test) appropriately
- Use Units class for all physical measurements
- Leverage LoggedTunableNumber for dashboard-adjustable constants in tuning mode
- Set Constants.TUNING_MODE = true for live parameter adjustment during development

### Hardware Abstraction

- Separate hardware interfaces (IO classes) from subsystem logic
- Create real, simulation, and replay implementations for each IO interface
- Use the pattern: `SubsystemIO`, `SubsystemIOReal`, `SubsystemIOSim`
- Always check for hardware failures and provide fallback behavior

### Safety & Reliability

- Implement software limits for all mechanisms
- Add current limiting to prevent brownouts
- Use Phoenix 6's built-in safety features
- Always validate sensor readings before using them
- Implement graceful degradation when sensors fail

## Domain-Specific Knowledge

### Swerve Drive

- This template uses CTRE Phoenix 6 Swerve modules with TalonFX integrated steering and drive
- Module configuration is in `TunerConstants.java` (generated by Phoenix Tuner X)
- Only TalonFX_Integrated configurations are supported by this template
- Drive commands should use field-relative control by default
- Implement proper wheel angle optimization
- Use odometry for accurate position tracking
- PathConstraints defined in Constants.java using TunerConstants
- PhoenixOdometryThread handles high-frequency odometry updates

### AdvantageKit Integration

- Use `LoggedRobot` instead of `TimedRobot`
- Implement IO interfaces for all hardware interactions
- Log inputs and outputs using `Logger.recordOutput()`
- Support real robot, simulation, and log replay modes
- Use proper metadata logging for build information

### PathPlanner & Choreo Integration

- **PathPlanner**: Configure path constraints in `Constants.java`
- Use PathPlanner's auto command factories
- Implement proper path following with feedback control
- Store autonomous routines in `src/main/deploy/pathplanner/autos/`
- **Choreo**: Alternative trajectory generation tool
- Choreo trajectories stored in `src/main/deploy/choreo/`
- Both tools can be used depending on team preference and requirements

### Vision System

- Integrate PhotonVision for AprilTag detection
- Use vision measurements to correct odometry drift
- Implement proper coordinate frame transformations
- Handle vision measurement rejection for outliers

## Code Generation Guidelines

### When creating new subsystems:

1. Create IO interface with inputs and outputs classes
2. Implement real hardware IO class
3. Implement simulation IO class
4. Create main subsystem class using IO abstraction
5. Add proper logging throughout
6. Include unit tests where applicable

### When creating new commands:

1. Extend `Command` or use factory methods
2. Declare subsystem requirements properly
3. Implement initialize(), execute(), end(), and isFinished()
4. Add logging for command state changes
5. Handle interruption gracefully

### When adding new sensors:

1. Create IO interface following AdvantageKit patterns
2. Implement proper sensor validation
3. Add simulation support
4. Log all sensor data
5. Implement fault detection and reporting

## File Naming Conventions

- Subsystems: `NameSubsystem.java`
- IO Interfaces: `NameIO.java`
- Real implementations: `NameIOReal.java` or `NameIOTalonFX.java`
- Simulation implementations: `NameIOSim.java`
- Commands: `VerbNounCommand.java` or use command factories

## Dependencies & Libraries

- Prefer WPILib built-in classes over third-party alternatives
- Use Phoenix 6 for CTRE devices (TalonFX, CANcoder, Pigeon2)
- Use REVLib for REV devices (SparkMax, etc.)
- Leverage AdvantageKit for all hardware abstraction
- Use PathPlanner for autonomous path planning
- Choreo available for trajectory generation
- PhotonVision for AprilTag detection
- Studica NavX for additional IMU support
- Jama for linear algebra operations
- SonarQube integration for code quality analysis

## Build System & Quality Tools

- **Spotless**: Automatic code formatting (Google Java Format, JSON, Markdown)
- **SonarQube**: Code quality analysis integrated with SonarCloud
- **Event Deployment**: Auto-commit on event branches during deployment
- **JUnit 5**: Unit testing framework
- **Gradle Tasks**: `./gradlew spotlessApply`, `./gradlew build`, `./gradlew deploy`

## Testing & Validation

- Test code in simulation before deploying to robot
- Use AdvantageScope for data analysis and debugging
- Implement unit tests for critical algorithms
- Validate all hardware configurations before competition
- Use proper error handling and user feedback

## Robot Configuration

- Team number and robot-specific settings in `.wpilib/` folder
- Vendor dependencies in `vendordeps/` folder
- Path files in `src/main/deploy/pathplanner/`
- Tuning constants should be easily accessible and well-documented

Remember: Safety first! Always consider what happens when hardware fails or sensors give bad readings. FRC robots operate in high-stress environments where reliability is crucial.
